#+TITLE: General Post
#+HUGO_BASE_DIR: ../
#+HUGO_SECTION: post
#+HUGO_AUTO_SET_LASTMO: t

* Iterator, IntoIterator, iter, iter_mut, into_iter
:PROPERTIES:
:EXPORT_FILE_NAME: rust-iterator-intoiterator-iter-intoiter
:END:

처음 rust 를 배우기 시작 했을때 Iterator 는 다른 언어들에서도 쉽게 봐왔던거라 어렵지 않게 넘어갔었는데, 이후 여러 코드를 보면 볼수록 정확히 모르고 있구나 라고 생각되던 상황에 [[https://www.youtube.com/watch?v=lQt0adYPdfQ&t=4158s][Rust Stream: Iterators]] 동영상을 보고 나름 개념정리가 된 듯 하여 글로 작성해 둔다.

Iterator trait 은 잘 알려진 반복자 디자인 패턴의 그 iterator 이다. Iterator trait 에는 아주 많은 함수가 있는데, 필수 구현해야 하는 함수는 fn next(&mut self) -> Option<Item> 하나이다. Option 타입을 반환하니 has_next() 같은 함수가 필요 없다.

Vec<T>는 Iterator trait 를 직접 구현하지 않는다. Iterator 를 구현하려면 현재 위치라는 상태를 가지고 있어야 하는데, trait 의 impl 에서 별도의 상태를 가질 수 없고, 그렇다고 Vec<T> 가 Iterator 를 위해 상태를 가질수도 없기 때문이다.

그래서 Iterator를 구현하는 별도의 타입이 존재하는데, Vec<T> 의 경우 Iter<'a, T>, IterMut<'a, T>, IntoIter<T> 3가지 이다. 이름에서 알 수 있듯이 Iter는 immutable, IterMut 는 mutable, IntoIter는 move 의 semantic 을 가지는 Iterator 이다. Iter 와 IterMut 는 대상 collection 을 레퍼런스로 가지고 있어 generic lifetime 변수를 명시해야 한다.

Vec<T> 에는 fn iter(&self), fn iter_mut(&mut self) 함수가 있는데 각각 Iter, IterMut 를 반환하는 함수들이다. 이 함수들 외에도 IntoIterator trait 의 into_iter() 함수로부터 위 iterator 들을 만들 수 있는데, 어떤 타입을 구현하는가에 따라 다른 iterator 를 만들게 된다. Vec 의 경우 &'a Vec<T>를 구현한 IntoIterator는 Iter를 &'a mut Vec<T> 를 구현한 IntoIterator는 IterMut를, 마지막으로 Vec<T>를 구현한 IntoIterator 는 IntoIter를 만들어 낸다. IntoIter 는 IntoIterator trait 의 구현 함수로부터만 얻어낼 수 있다.

Vec의 iter() 함수 말고도 IntoIterator trait 이 존재하는 이유는, 컴파일러가 이 trait 을 구현한 타입의 변수를 for loop 문법에서 그냥 사용할 수 있게 해 주기 때문이다. Java 의 for in 문장에서 Iterable 을 구현한 객체를 바로 사용 할 수 있는 것과 동일한 것으로 이해된다.

아래 코드에서 values는 Vec<i32> 타입이고 Iterator 가 아니지만 IntoIterator 를 구현하고 있으므로 for 에서 values.iter() 로 Iterator 를 얻지 않고도 바로 사용할 수 있다. 아래 코드는 for x in values.into_iter() 로 해석할 수 있다. 단, 여기서는 IntoIter iterator가 만들어지고, x는 i32 타입이다. 그리고 move 되었으므로 for 이후에는 values 를 사용할 수 없게 된다.

#+begin_src rust
let values = vec![1, 2, 3];
for x in values {
    println!("{x}");
}
#+end_src

move 가 아닌 borrow 를 하려면, 즉 Iter iterator를 얻으려면 아래와 같이 values의 레퍼런스를 명시하면 되고, 이 경우 x 는 &i32 타입이 된다.

#+begin_src rust
let values = vec![1, 2, 3];
for x in &values {
    println!("{x}");
}
println!("{}", values[0]); // OK
#+end_src


이 정도면 Iterator, IntoIterator, Iter, IterMut, IntoIter, iter, iter_mut, into_iter 등에 대한 개념은 잡히지만, 알아야 할 것들은 충분히 더 있다.

* evil-mode

요 몇일동안 vi를 공부 했는데, 그 동안 에디터를 제대로 활용하고 있지 못했구나라는 생각이 든다.
정말 말 그대로 공부다. Oreilly 에서 Vim Masterclass라는 5시간 정도되는 동영상 강의를 따라하면서 봤다.
Vim Masterclass 강의 추천한다.

* blogging, emacs, ox-hugo, hugo, github :emacs:hugo:
SCHEDULED: <2021-10-23 Sat 21:00>
:PROPERTIES:
:EXPORT_FILE_NAME: blogging-emacs-ox-hugo
:END:

블로깅을 시작하겠다고 hugo 셋팅하고 간단하게 github 에다 테스트 같은 포스트 하나 올려놓고 방치해 놨었는데 이제 진짜 해보려 한다. 블로깅 환경은 hugo, emacs, ox-hugo, github page 이다. 흐름은 emacs 에서 org 문서 형태로 포스트 작성하고 ox-hugo 를 이용해 hugo markdown 파일로 변환한 후, 미리 작성된 스크립트로 publish 하게 된다. hugo - github 연동은 잘 알려진 내용이니 ox-hugo - hugo 부분만 간단히 정리한다.

** github action

[2022-05-01 Sun] 추가

최근에 JAMstack 이라는 용어가 눈에 띄어 찾아 보다 여기가 생각나서 github action 으로 편하게 사용할 수 있는 방법이 있음을 알게 되었다.

https://gohugo.io/hosting-and-deployment/hosting-on-github/ 참고. github action 설정 파일만 추가하면 된다.

github page 저장소와 소스 저장소가 분리되어 있어 정리하는 과정이 있긴 했지만, 큰 수고 없이 좀 더 편하게 deploy 할 수 있게 되었다.

이전에 분리했던 이유는 아마도 퍼블리쉬 전 소스를 private 으로 관리하고자 하는 의도였을거 같은데 딱히 그럴 필요도 없고 실제로도 private 도 아니었다.

** 왜 ox-hugo 를 써야 할까?

ox-hugo 는 org 문서를 hugo 에 최적화된 markdown 문서로 변환해 주는 org exporter 이다. hugo 에서 org 문서 형식을 지원 하는데도 ox-hugo 를 사용해야 하는 이유가 궁금했는데 [[https://zzamboni.org/post/my-blogging-setup-with-emacs-org-mode-ox-hugo-hugo-gitlab-and-netlify/][이 글]]을 보고 조금은 이해가 되었다. 가장 큰 이유는 org full support 여부이고, 두 번째는 좀 더 org 문서 스타일로 사용할 수 있다는 점이다. 원래 hugo는 [[https://github.com/niklasfasching/go-org][go-org]] 를 내장하고 있어 org 문서를 지원한다고는 하지만, go 로 구현된 변환기라 org 문서의 모든 형식을 완전히 지원하지 못한다.

** 내용 작성

org 문서에 =HUGO_BASE_DIR=, =HUGO_SECTION= 속성을 지정해야 하는데, 이 속성값에 따라 md 파일이 생성된다. 본 블로그는 hugo 사이트 디렉토리 아래에 org 디렉토리를 두고 base dir 을 =..= 로 설정하였다.

ox-hugo 는 단일 org 파일을 md 파일로 변환할수도 있고, 하나의 org 문서 내 하위 섹션을 md 파일로도 변환할 수 있는데, 후자의 방법을 권장한다. 포스트 작성 시 hugo 컨텐츠의 front matter 에 해당하는 설정을 org 문서 내에 해 줘야 하는데, 후자의 방법을 사용하면 부모 섹션의 설정을 하위 섹션에서 그대로 상속받게 되어 동일한 설정을 여러번 반복해서 작성할 필요가 없다.

실제 사용 사례는 [[https://ox-hugo.scripter.co/doc/examples/][Real World Examples]] 을 참고한다.

** 사용법

minor mode 인 =org-hugo-auto-export-mode= 를 사용하면 org 파일을 저장할 때마다 front matter 의 설정에 따라 md 파일로 저장되다. =hugo server= 실행하고 페이지 열어두면 저장할 때마다 자동으로 반영되는것을 확인할 수 있다.

** 참고
- https://gohugo.io
- https://ox-hugo.scripter.co/
- https://zzamboni.org/post/my-blogging-setup-with-emacs-org-mode-ox-hugo-hugo-gitlab-and-netlify/

* New Arrival
SCHEDULED: <2020-09-14 Mon>
:PROPERTIES:
:EXPORT_FILE_NAME: new-arrival
:END:

다시 hugo 블로그를 셋업했다.
